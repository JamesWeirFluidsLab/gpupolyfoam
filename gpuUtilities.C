#include "gpuUtilities.h"


void initialiseOMM(struct poly_solver_t* solver)
{
	// Load OpenMM platform-specific plugins:
    	
	Platform::loadPluginsFromDirectory(Platform::getDefaultPluginsDirectory());
	int numPlatforms = Platform::getNumPlatforms();
	cout<<numPlatforms<<" OMM platforms found on this system"<<std::endl;
	for(int i=0;i<numPlatforms;i++)
   	{	
        Platform& tempPlatform = OpenMM::Platform::getPlatform(i);
		std::string tempPlatformName = tempPlatform.getName();
		cout << "Platform " << i << 
		" is " << tempPlatformName.c_str() << std::endl;
	}
	cout<<"==================================\n"<<std::endl;
	solver->system = new System();
	MOLECULE& tempmol = *solver->molecules;

        //get the scalling function required for this simulation
        Foam::word scallingfunction = getScallingFunction(tempmol);
        Info << "Scalling function " << scallingfunction << nl;
       
	//dynamic coeff string array
	std::vector<std::string> coeffStr;
/*
 * extract the coeff parameters generated by polyIdPairs class
 * from potentialDict
 */ 
        
	extractCoeffParameters(tempmol,*solver->plid,coeffStr);
        std::string coefftype = solver->plid->coeffType();
        Info << "CoeffType " << coefftype << nl;
        
        const label cs = solver->plid->coeffSize();
        const List<word>& coeffnames = solver->plid->coeffNames();
        
        std::stringstream tempstr;
	/*
         * gather the N coeff parameters and their repective coeff string
         * generated by polyIdPairs.
         */
        for(int i=0;i<cs;++i){
            tempstr << coeffnames[i] << "= " << coeffStr[i] << ";";
        }
        
        std::string formulastr;
        
        if(coefftype == "lennardJones"){
            formulastr = 
            
"4*epsilon*((sigma/r)^12-(sigma/r)^6)+(138.9354561469*q)*(1/r-1/rCut+(r-rCut)/rCut^2); " 
            + tempstr.str() + " q=q1*q2";
        }
        else if(coefftype == "morse"){
            formulastr = "D*(exp(-2*alpha*(r-r0))-2*exp(-alpha*(r-r0)));"
                    + tempstr.str();
        }
        else{
            Info << "no coeff type found, quitting ..." << nl;
            exit(-1);
        }
        
        Info << "====Equation====" << nl;
        Info << formulastr << nl;

// Initialise customNonbonded force for OpenMM	
    CustomNonbondedForce* nonbonded;
    
    if(scallingfunction == "shiftedForce"){
        // ================================================
        // Coulomb potential with shifted force correction:
        // ================================================
        nonbonded = new CustomNonbondedForce(formulastr);
        nonbonded->addGlobalParameter("rCut",solver->rCutInNM);
    }
    else{
        Info << "Error: (Solver) Cannot find electrostatic potential" <<
                "specification in potentialDict" << nl;
        exit(-1);
    }
    
    //add per particles to nonbonded force
    addParticlesToNonBonded(nonbonded,solver);
//set OMM box size
    solver->system->setDefaultPeriodicBoxVectors(
        Vec3(solver->bBoxOMMinNm[0],0,0),
        Vec3(0,solver->bBoxOMMinNm[0],0),
        Vec3(0,0,solver->bBoxOMMinNm[0])
        );

/**
 * extract OF information to initialise the
 * system inside openmm, this information includes
 * masses, exclusion list, custom parameters, etc
 */
    extractOFParticles(solver,nonbonded);
    
    Info << "CUSTOMNONBONDEDFORCE INFO"<<nl;
    Info << "Num particles "<< nonbonded->getNumParticles() << nl;
    Info << "Num exclusion "<< nonbonded->getNumExclusions() << nl;
    Info << "Num perparticle params "<< nonbonded->getNumPerParticleParameters() 
<< nl;
    Info << "Num global params "<< nonbonded->getNumGlobalParameters() << nl;
    Info << "Nonbonded method "<< nonbonded->getNonbondedMethod() << nl;
    Info << "Cutoff distance "<< nonbonded->getCutoffDistance() << nl;
    Info << "==============================="<<nl;    

    
    solver->system->addForce(nonbonded);
    
    Platform& platform = Platform::getPlatformByName("OpenCL");
    solver->integrator =  new VelocityVerletIntegrator(solver->deltaT*OpenMM::PsPerFs);
    solver->context = new Context(*solver->system,*solver->integrator,platform);
    
    Info << "Initialised sytem on OMM with " <<
        solver->system->getNumParticles() <<
        " particles " << nl;
    Info << "Using OMM "<<
        solver->context->getPlatform().getName().c_str() <<
    	" platform " << nl;
    
}


void extractCoeffParameters(const MOLECULE& mol,
			const polyIdPairs& p,
			std::vector<std::string>& coeffStr)
{

	const List<word>& idList = mol.pot().siteIdList();
	const List<word>& coefflist = p.coeffNames();
	label coeffsize = coefflist.size();
	std::vector<std::string> coeffstr(coeffsize);

	int counter = 0;
	for(label c = 0; c < coeffsize; ++c)
	{
		counter = 0;
		forAll(p.coeffVals()[c],i){
			forAll(p.coeffVals()[c][i],j){
				const word& idAStr = idList[i];
				const word& idBStr = idList[j];
//TODO: delete later if all is well				
				scalar coeffAB;
                                
				if(coefflist[c] == "sigma")
                                    coeffAB = p.coeffVals()[c][i][j]/1e-9;
				else if(coefflist[c] == "epsilon")
                                    coeffAB = 
p.coeffVals()[c][i][j]*6.02214129e23/1e3f;
                                else if(coefflist[c] == "D")
                                    coeffAB = p.coeffVals()[c][i][j] * 
6.02214129e20;
                                else if(coefflist[c] == "alpha")
                                    coeffAB = p.coeffVals()[c][i][j] * 1.0f / 
1e9;
                                else if(coefflist[c] == "r0")
                                    coeffAB = p.coeffVals()[c][i][j] * 1e9;
                                
				std::string ABstr;
				std::stringstream outAB;		
				outAB << coeffAB;
				ABstr = outAB.str();
				std::string tempstr = 
ABstr+"*("+idAStr+"1*"+idBStr+"2)";

				if(counter == 0)
					coeffstr[c] = coeffstr[c]+""+tempstr;
				else
					coeffstr[c] = coeffstr[c]+" + "+tempstr;	
		
				counter++;
			}
		}
	}

	for(counter = 0; counter < coeffsize; ++counter)
		coeffStr.push_back(coeffstr[counter]);
}

void extractOFParticles(struct poly_solver_t* solver,
                        CustomNonbondedForce* const nonbonded)
{
    const std::string coefftype = solver->plid->coeffType();
    int temp = 0;
    
    if(coefftype == "lennardJones")
        temp = solver->plid->nIds() + 1;
    else
        temp = solver->plid->nIds();
    
    const int species = temp;
    int numMolecules = 0;
    int numParticles = 0;
    
    int* midx=NULL;
	 
    MOLECULE& mol = *solver->molecules;
    IDLList<TypeMolecule>::iterator m(mol.begin());
    for (m = mol.begin(); m != mol.end(); ++m)
    {
	const TypeMolecule::constantProperties& constprop = 
                    mol.constProps(m().id());
#ifdef MONO
    int molsize = 1;
#else
    int molsize = constprop.sites().size();
#endif
	numMolecules++;

	//allocate memory for array holding molecule index based on molecule size
	midx = (int*) malloc(sizeof(int)*molsize);

	//now traverse throught the N sites of each molecule size obtained
	//from previous retrive
	int itr = 0;
	
	while(itr<molsize)
	{
#ifdef MONO
            double tempmolmass = constprop.mass()*solver->refMass/DALTON;
	    double tempmolcharge = constprop.site().siteCharge()*solver->refCharge/CHARGE;
	    int sid = constprop.site().siteId();
#else
	    double tempmolmass = constprop.sites()[itr].siteMass()
		    *solver->refMass/DALTON;
	    double tempmolcharge = constprop.sites()[itr].siteCharge()
		    *solver->refCharge/CHARGE;
            int sid = constprop.sites()[itr].siteId();
#endif
	    midx[itr]  = solver->system->addParticle(tempmolmass);
	    
	    std::vector<double> params(species);
	    for(int k=0;k<species;k++)
		params[k]=0;
	    params[sid] = 1;
#ifndef MONO 
	    if(coefftype == "lennardJones")
		    params[species-1] = tempmolcharge;
#endif
	    
	    nonbonded->addParticle(params);
	    itr++;
	    numParticles++;
	}
//             Info << " " << nl;
	//add exclusion for each molecule obtained
	if(molsize>1)
		    for(int i=0;i<molsize-1;i++)
			    for(int j=i+1;j<molsize;j++)
				    nonbonded->addExclusion(midx[i],midx[j]);
	// clear the mol id list for further assignment
	free(midx);

    }//first for loop ends
    
    solver->isMolecular = (bool) numMolecules != numParticles;
    
    if(solver->isMolecular){
        /**
         * if the simulation is molecular then assign the required
         * information to the openmm system to enable molecular integration
         * to occur seamlessly 
         * 
         * *assign the unique number of molecules in the simulation
         * by obtaining the number from openfoam
         * 
         */
#ifndef MONO
        solver->system->setNumberofIds(solver->uniqueMolecules);
	solver->system->setIsMolecular(solver->isMolecular);
#endif
    }
}

void extractMolecularInfo(poly_solver_t* solver,std::vector<int>& moleculeInfo)
{
    IOdictionary moleculePropertiesDict
    (
	IOobject
	(
	    "moleculeProperties",
	    solver->molecules->mesh().time().constant(),
	    solver->molecules->mesh(),
	    IOobject::MUST_READ,
	    IOobject::NO_WRITE
	)
    );
    
    const List<word> mols (moleculePropertiesDict.lookup("idList"));
    const dictionary& subdict(moleculePropertiesDict.subDict("moleculeProperties"));
    List<word> ids(subdict.toc());
    if(ids.size() != mols.size())
      FatalErrorIn("GpuPolyFoam::molecularInfo()") << 
		" IdList size cannot be collected properly " <<
		abort(FatalError);

    solver->uniqueMolecules = (int) mols.size();
    moleculeInfo.resize(solver->uniqueMolecules);
    
    int ctr = 0;
    while(ctr < solver->uniqueMolecules){
	List<word> temp(subdict.subDict(ids[ctr]).lookup("siteIds"));
	int s = temp.size();
	if(s == 1)
	    moleculeInfo[ctr] = 1;
	else{
	    word common = temp[0];
	    int unique = 1;
	    int same = 1;
	    for(int i = 1;i<s;++i){
		if(common == temp[i])
		    same++;    
	    }
	    unique += (s - same);
	    moleculeInfo[ctr] = unique;
	}
	++ctr;
    }
}



int extractOFPostoOMM(std::vector<Vec3>& posInNm,struct poly_solver_t* sol,
                      const boundBox& bb)
{
    posInNm.clear();
    int numMols = 0;
    int numParticles = 0;
    
    IDLList<TypeMolecule>::iterator mol(sol->molecules->begin());
    for (mol = sol->molecules->begin(); mol != sol->molecules->end(); ++mol)
    {
#ifdef MONO
        int molsize = 1;
#else
        int molsize = mol().sitePositions().size();
#endif
        int m = 0;
        while (m<molsize) {
#ifdef MONO
	    Foam::vector rI = (mol().position() - bb.min()) * sol->refLength*NM;
#else
            Foam::vector rI = (mol().sitePositions()[m] - bb.min())*sol->refLength*NM;
#endif
            posInNm.push_back(Vec3(rI.x(), rI.y(), rI.z()));
            m++;
            numParticles += 1;
        }
        numMols++;
    }
    
    return numParticles;
 
}

int extractOFVeltoOMM(std::vector<Vec3>& velInNm, struct poly_solver_t* sol,int particles)
{
	int numMols = 0;
	velInNm.clear();
	const double nmconversion = sol->refVelocity*1e-12/NANO;    	
	IDLList<TypeMolecule>::iterator mol(sol->molecules->begin());
	
	for (mol = sol->molecules->begin(); mol != sol->molecules->end(); 
++mol){
		numMols++;
		Foam::vector vi = mol().v()*nmconversion;
		velInNm.push_back(Vec3(vi.x(),vi.y(),vi.z()));
	}

	return numMols;
}

int setOFforce(struct poly_solver_t* solver, const std::vector<Vec3>& ommForces)
{
	IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());
	int numparticle = 0;

    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); 
++mol){
#ifdef MONO
        int molsize = 1;
#else
	int molsize = mol().siteForces().size();
#endif
        int m = 0;
	while(m<molsize){
#ifdef MONO
	  mol().f() = Foam::vector(
	      ommForces[numparticle][0],
	      ommForces[numparticle][1],
	      ommForces[numparticle][2]
	  )*NM2RUF/solver->refForce;
#else
	  mol().siteForces()[m] = Foam::vector                     

	  (
	      ommForces[numparticle][0],
	      ommForces[numparticle][1],
	      ommForces[numparticle][2]
	  )*NM2RUF/solver->refForce;
#endif
	  numparticle++;
	  m++;
	}
     }
	return numparticle;
}

//set OMM box
void setOMMBox(struct poly_solver_t* solver, const boundBox& bBoxOF,const double 
dt)
{
	solver->refLength = solver->redUnits->refLength();
	solver->refMass = solver->redUnits->refMass();
	solver->refForce = solver->redUnits->refForce();
	solver->refCharge = solver->redUnits->refCharge();
	solver->refTime = solver->redUnits->refTime();
	solver->refVelocity = solver->redUnits->refVelocity();
	// Convert to femtoseconds [fs] for OpenMM: 
	solver->deltaT = dt*solver->refTime/FEM2SEC;
	
	//convert to reduced omm rcut size
	solver->rCutInNM = 
solver->molecules->pot().pairPotentials().rCutMax()*solver->refLength/NANO;
	// Convert individual bounding-box length-scales to nanometres [nm]
	double Lx = bBoxOF.span().x()*solver->refLength/NANO;
	double Ly = bBoxOF.span().y()*solver->refLength/NANO;
	double Lz = bBoxOF.span().z()*solver->refLength/NANO;
	//create boxsize for OMM 
	solver->bBoxOMMinNm = Vec3(Lx,Ly,Lz);
	
}


void addParticlesToNonBonded(CustomNonbondedForce* const nonbonded,
                                const struct poly_solver_t* solver)
{
    const List<word>& idlist = solver->molecules->pot().siteIdList();
    const std::string coefftype = solver->plid->coeffType();
    
    for(int i = 0; i < solver->plid->nIds(); ++i){
        const word& idAstr = idlist[i];
        nonbonded->addPerParticleParameter(idAstr);
    }
    if(coefftype == "lennardJones")
        nonbonded->addPerParticleParameter("q");
    
    //set nonbondedmethod
    nonbonded->setNonbondedMethod(CustomNonbondedForce::CutoffPeriodic);
    nonbonded->setCutoffDistance(solver->rCutInNM);
}

void getOMMState(const Context* context,std::vector<Vec3>& statearray)
//        enum STATES st)
{
	statearray.clear();
	State state = 
context->getState(OpenMM::State::Forces|State::Energy,true);
	statearray = state.getForces();
        
}


int extractOFQ(const struct poly_solver_t* solver, std::vector<OpenMM::Tensor>& moleculeQ)
{
    int numMols = 0;
#ifndef MONO
    moleculeQ.clear();    
    IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());
    
    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); ++mol)
    {
	numMols++;
	Foam::tensor& temp = mol().Q();
	moleculeQ.push_back(
	      OpenMM::Tensor(temp.xx(),temp.xy(),temp.xz(),
	      temp.yx(),temp.yy(),temp.yz(),
	      temp.zx(),temp.zy(),temp.zz()));
    }
#endif
    return numMols;
}

int extractOFSiteRefPositions(const struct poly_solver_t* solver, std::vector<OpenMM::Vec3>& siteRefPositions)
{
    const double converter = solver->refLength*NM;
    int numMols = 0;
    siteRefPositions.clear();
    int uniquemolnumber = solver->uniqueMolecules;
#ifndef MONO    
    while(numMols<uniquemolnumber)
    {
	const TypeMolecule::constantProperties& constprop = solver->molecules->constProps(numMols);
	int molsize = constprop.sites().size();
	int a = 0;
	while(a<molsize){
		const Foam::vector& vi = constprop.sites()[a].siteReferencePosition()*converter;
		siteRefPositions.push_back(OpenMM::Vec3(vi.x(),vi.y(),vi.z()));
		a++;
	}
	numMols++;
    }
#endif
    return numMols;
}

int extractMoleculePositions(const struct poly_solver_t* solver, std::vector<OpenMM::Vec3>& moleculePositions){
	const double converter = solver->refLength*NM;
	int numMols = 0;
	moleculePositions.clear();

	IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());

	for (mol = solver->molecules->begin(); mol!=solver->molecules->end(); ++mol)
	{
		const Foam::vector& vi = mol().position()*converter;
		moleculePositions.push_back(OpenMM::Vec3(vi.x(),vi.y(),vi.z()));
		numMols++;
	}	
	
	return numMols;
}

int extractMoleculePI(const struct poly_solver_t* solver, std::vector<OpenMM::Vec3>& moleculePI)
{
	double sqvel = solver->refVelocity*solver->refLength*solver->refMass;
	const double converter = sqvel*1e6/DALTON;
#ifndef MONO
	moleculePI.clear();
	int numMols = 0;
	IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());
	for (mol = solver->molecules->begin(); mol!=solver->molecules->end(); ++mol)
	{
		const Foam::vector& pi = mol().pi()*converter;
		moleculePI.push_back(OpenMM::Vec3(pi.x(),pi.y(),pi.z()));
		numMols++;
	}
#endif
}

void setOFPI(poly_solver_t* solver, const std::vector< Vec3 >& moleculePI)
{
    IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());
    double sqvel = solver->refVelocity*solver->refLength*solver->refMass;
    const double converter = sqvel*1e6/DALTON;
    int counter = 0;
#ifndef MONO
    for(mol=solver->molecules->begin();mol!=solver->molecules->end();++mol)
    {
        Info << "PI " << counter<< "=> " <<
        moleculePI[counter][0] << " " <<
        moleculePI[counter][1] << " " <<
        moleculePI[counter][2] <<nl;
        mol().pi() = Foam::vector(moleculePI[counter][0],
	    moleculePI[counter][1],moleculePI[counter][2])/converter;
	Info << "Vel " << mol().pi() << nl;
	counter++;
    }
#endif
}


void setOFPositions(poly_solver_t* solver, const std::vector< Vec3 >& posInNm)
{
    IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());
    int counter = 0;
    double divisor = NANO/solver->refLength;

    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); 
++mol)
    {
        mol().position() = Foam::vector(
                                  posInNm[counter][0],
                                  posInNm[counter][1],
                                  posInNm[counter][2]
                                  )* divisor;
	
        bool inCell = solver->molecules->mesh().pointInCell(mol().position(), mol().cell());

        if(!inCell)
        {
            label cellI = solver->molecules->mesh().findCell(mol().position());

            if(cellI != -1)
            {
                mol().cell() = cellI;
            }
            else
            {
                printf("MolPOs: Error raised by incell check\n");
            }
        }
        counter++;
    }
}

void setOFVelocities(poly_solver_t* solver, const std::vector< Vec3 >& velInNm)
{
    IDLList<TypeMolecule>::iterator mol(solver->molecules->begin());                                                       
    int counter = 0;
    double divisor = NANO/(solver->refVelocity*E12);
    
    for(mol = solver->molecules->begin();mol!=solver->molecules->end();++mol)                                                            
    {
        mol().v() = Foam::vector(
                                velInNm[counter][0],                                                   
                                velInNm[counter][1],                                                   
                                velInNm[counter][2]                                                    
                                )*divisor;                                                     
        counter++;
    }
}

void setOFSitePositions(poly_solver_t* solver, const std::vector< Vec3 >& sitePositions)
{
#ifndef MONO
    MOLECULE& mol = *solver->molecules;
    IDLList<TypeMolecule>::iterator m(mol.begin());
    double converter = NANO/solver->refLength;
    
    int atomCounter = 0;
    for (m = mol.begin(); m != mol.end(); ++m)
    {
	const TypeMolecule::constantProperties& constprop = 
		mol.constProps(0);
	int molsize = constprop.sites().size();
	int counter = 0;
	List<Foam::vector>& sitepos = m().sitePositions();
	while(counter<molsize){
	    sitepos[counter] = Foam::vector(
		sitePositions[atomCounter][0],
		sitePositions[atomCounter][1],
		sitePositions[atomCounter][2]
	    ) * converter;

	    ++atomCounter;
	    counter++;
	}//while loop
	    
	bool inCell = solver->molecules->mesh().pointInCell(m().position(), m().cell());

        if(!inCell)
        {
            label cellI = solver->molecules->mesh().findCell(m().position());

            if(cellI != -1)
            {
                m().cell() = cellI;
            }
            else
            {
                printf("Error raised by incell check in site positions\n");
            }
        }    
    }//for loop
#endif
}

void extractMomentOfInertia(poly_solver_t* solver, std::vector< Vec3 >& momentOfInertia,
      std::vector<std::vector<unsigned int> >& moleculeState
)
{
#ifndef MONO
    int n = 0;
    const double moIconversion = (solver->refLength * solver->refLength * solver->refMass * E18)/DALTON;
    
    /**
    * assigning moment of inertia of openfoam to OpenMM
    * this process also covers converting the OF values to 
    * equivalent OMM measurements
    * 
    * an array signifying OF values which specifies the molecular status
    * of each type of molecule, such as 
    * if pointMolecule
    * if LinearMolecule
    * not PointMolecule
    * not LinearMolecule
    * this is arranged in array in the form specified above
    * therefore 0,1,2,3
    */
    
    int uniquemol = solver->uniqueMolecules;
    momentOfInertia.resize(uniquemol);
    moleculeState.resize(uniquemol);
    
    while(n<uniquemol){
      const TypeMolecule::constantProperties& constprop = solver->molecules->constProps(n);
      const diagTensor& m = constprop.momentOfInertia();
      momentOfInertia[n] = OpenMM::Vec3(m.xx()*moIconversion,m.yy()*moIconversion,m.zz()*moIconversion);
      unsigned int pm = (unsigned int) constprop.pointMolecule();
      unsigned int lm = (unsigned int) constprop.linearMolecule();
      unsigned int npm = (unsigned int) !constprop.pointMolecule();
      unsigned int nlm = (unsigned int) !constprop.linearMolecule();
      
      moleculeState[n].push_back(pm);
      moleculeState[n].push_back(lm);
      moleculeState[n].push_back(npm);
      moleculeState[n].push_back(nlm);
      
      n++;
    }
#endif
}



