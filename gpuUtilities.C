#include "gpuUtilities.h"


void initialiseOMM(struct poly_solver_t* solver)
{
	// Load OpenMM platform-specific plugins:
    	Platform::loadPluginsFromDirectory(Platform::getDefaultPluginsDirectory());
	int numPlatforms = Platform::getNumPlatforms();
	cout<<numPlatforms<<" OMM platforms found on this system"<<std::endl;
	for(int i=0;i<numPlatforms;i++)
   	{	
        Platform& tempPlatform = OpenMM::Platform::getPlatform(i);
		std::string tempPlatformName = tempPlatform.getName();
		cout << "Platform " << i << 
		" is " << tempPlatformName.c_str() << std::endl;
	}
	cout<<"==================================\n"<<std::endl;
	solver->system = new System();
	MOLECULE& tempmol = *solver->molecules;

    //get the scalling function required for this simulation
    Foam::word scallingfunction = getScallingFunction(tempmol);
    Info << "Scalling function " << scallingfunction << nl;
       
	//dynamic coeff string array
	std::vector<std::string> coeffStr;
/*
 * extract the coeff parameters generated by polyIdPairs class
 * from potentialDict
 */ 
        
	extractCoeffParameters(tempmol,*solver->plid,coeffStr);
        std::string coefftype = solver->plid->coeffType();
        Info << "CoeffType " << coefftype << nl;
        
        const label cs = solver->plid->coeffSize();
        const List<word>& coeffnames = solver->plid->coeffNames();
        
        std::stringstream tempstr;;
	/*
         * gather the N coeff parameters and their repective coeff string
         * generated by polyIdPairs.
         */
        for(int i=0;i<cs;++i){
            tempstr << coeffnames[i] << "= " << coeffStr[i] << ";";
        }
        
        std::string formulastr;
        
        if(coefftype == "lennardJones"){
            formulastr = 
            "4*epsilon*((sigma/r)^12-(sigma/r)^6); " + tempstr.str();
        }
        else if(coefftype == "morse"){
            formulastr = "D*(exp(-2*alpha*(r-r0))-2*exp(-alpha*(r-r0)));"
                    + tempstr.str();
        }
        else{
            Info << "no coeff type found, quitting ..." << nl;
            exit(-1);
        }
        
        Info << "====Equation====" << nl;
        Info << formulastr << nl;
	
// Initialise customNonbonded force for OpenMM	
    CustomNonbondedForce* nonbonded;
    NonbondedForce* nbonded;
    
    if(scallingfunction == "shiftedForce"){
        // ================================================
        // Coulomb potential with shifted force correction:
        // ================================================
        nonbonded = new CustomNonbondedForce(formulastr);
        nonbonded->addGlobalParameter("rCut",solver->rCutInNM);
	nbonded = new NonbondedForce();
	nbonded->setNonbondedMethod(NonbondedForce::Ewald);
	nbonded->setCutoffDistance(solver->rCutInNM);
	nbonded->setEwaldErrorTolerance(EWALD_ERR);

    }
    else{
        Info << "Error: (Solver) Cannot find electrostatic potential" <<
                "specification in potentialDict" << nl;
        exit(-1);
    }
    
    //add per particles to cnonbonded force
    addParticlesToNonBonded(nonbonded,solver);
//set OMM box size
    solver->system->setDefaultPeriodicBoxVectors(
        Vec3(solver->bBoxOMMinNm[0],0,0),
        Vec3(0,solver->bBoxOMMinNm[0],0),
        Vec3(0,0,solver->bBoxOMMinNm[0])
        );

/**
 * extract OF information to initialise the
 * system inside openmm, this information includes
 * masses, exclusion list, custom parameters, etc
 */
    extractOFParticles(solver,nonbonded,nbonded);
    
    Info << "CUSTOMNONBONDEDFORCE INFO"<<nl;
    Info << "Num particles "<< nonbonded->getNumParticles() << nl;
    Info << "Num exclusion "<< nonbonded->getNumExclusions() << nl;
    Info << "Num perparticle params "<< nonbonded->getNumPerParticleParameters() << nl;
    Info << "Num global params "<< nonbonded->getNumGlobalParameters() << nl;
    Info << "Nonbonded method "<< nonbonded->getNonbondedMethod() << nl;
    Info << "Cutoff distance "<< nonbonded->getCutoffDistance() << nl;
    Info << "==============================="<<nl;    

    solver->system->addForce(nonbonded);
    //add another force to system
    solver->system->addForce(nbonded);
    Platform& platform = Platform::getPlatformByName("OpenCL");
    solver->integrator =  new VerletIntegrator(solver->deltaT*OpenMM::PsPerFs);
    solver->context = new Context(*solver->system,*solver->integrator,platform);
    
    Info << "Initialised sytem on OMM with " <<
        solver->system->getNumParticles() <<
        " particles " << nl;
    Info << "Using OMM "<<
        solver->context->getPlatform().getName().c_str() <<
    	" platform " << nl;
    
}


void extractCoeffParameters(const MOLECULE& mol,
			const Pairs& p,
			std::vector<std::string>& coeffStr)
{

	const List<word>& idList = mol.pot().siteIdList();
	const List<word>& coefflist = p.coeffNames();
	label coeffsize = coefflist.size();
	std::vector<std::string> coeffstr(coeffsize);

	int counter = 0;
	for(label c = 0; c < coeffsize; ++c)
	{
		counter = 0;
		forAll(p.coeffVals()[c],i){
			forAll(p.coeffVals()[c][i],j){
				const word& idAStr = idList[i];
				const word& idBStr = idList[j];
//TODO: delete later if all is well				
				scalar coeffAB;
                                
				if(coefflist[c] == "sigma")
                                    coeffAB = p.coeffVals()[c][i][j]/1e-9;
				else if(coefflist[c] == "epsilon")
                                    coeffAB = p.coeffVals()[c][i][j]*6.02214129e23/1e3f;
                                else if(coefflist[c] == "D")
                                    coeffAB = p.coeffVals()[c][i][j] * 6.02214129e20;
                                else if(coefflist[c] == "alpha")
                                    coeffAB = p.coeffVals()[c][i][j] * 1.0f / 1e9;
                                else if(coefflist[c] == "r0")
                                    coeffAB = p.coeffVals()[c][i][j] * 1e9;
                                
				std::string ABstr;
				std::stringstream outAB;		
				outAB << coeffAB;
				ABstr = outAB.str();
				std::string tempstr = ABstr+"*("+idAStr+"1*"+idBStr+"2)";

				if(counter == 0)
					coeffstr[c] = coeffstr[c]+""+tempstr;
				else
					coeffstr[c] = coeffstr[c]+" + "+tempstr;			
				counter++;
			}
		}
	}

	for(counter = 0; counter < coeffsize; ++counter)
		coeffStr.push_back(coeffstr[counter]);
}

void extractOFParticles(struct poly_solver_t* solver,
                        CustomNonbondedForce* const nonbonded,
			NonbondedForce* const nbonded
 		      )
{
    const std::string coefftype = solver->plid->coeffType();
    int temp = 0;
    
    /*
    // this is for charge particle in lennardJones equation string
    if(coefftype == "lennardJones")
        temp = solver->plid->nIds() + 1;
    else*/
        // this becomes simply the same size because there is no
        // more charge particles included in equation
        // original: temp = solver->plid->nIds() + 1;
        temp = solver->plid->nIds();
    
    const int species = temp;
    
    int* midx=NULL;
    int counter = 0;
	 
    MOLECULE& mol = *solver->molecules;
    IDLList<polyMolecule>::iterator m(mol.begin());
    for (m = mol.begin(); m != mol.end(); ++m)
    {
            const polyMolecule::constantProperties& constprop = 
                    mol.constProps(m().id());
            int molsize = constprop.sites().size();


            //allocate memory for array holding molecule index based on molecule size
            midx = (int*) malloc(sizeof(int)*molsize);
	    // charge product
	    double chargeProd = 0.0;

            //now traverse throught the N sites of each molecule size obtained
            //from previous retrive
            int itr = 0;
            while(itr<molsize)
            {
                double tempmolmass = constprop.sites()[itr].siteMass()
                        *solver->refMass/DALTON;
                //no more charge required
               double tempmolcharge = constprop.sites()[itr].siteCharge()
                       *solver->refCharge/CHARGE;
                midx[itr]  = solver->system->addParticle(tempmolmass);
                int sid = constprop.sites()[itr].siteId();
         
                std::vector<double> params(species);
                for(int k=0;k<species;k++)
                    params[k]=0;
                params[sid] = 1;
		/**
		 * because there is not q parameter so assigning charge value
		 * does not makes sense
		 */
		
//                 if(coefftype == "lennardJones")
//                         params[species-1] = tempmolcharge;
                chargeProd *= tempmolcharge;
                nonbonded->addParticle(params);
		nbonded->addParticle(tempmolcharge*138.9354561469, 0.0, 0.0);
		nbonded->setParticleParameters(counter,tempmolcharge*138.9354561469,0.0,0.0);
                
                itr++;
		counter++;//global counter for atom indices
            }
            //add exclusion for each molecule obtained
            if(molsize>1)
	        for(int i=0;i<molsize-1;i++){
		    int idx = midx[i];
		    for(int j=i+1;j<molsize;j++){
		        int jdx = midx[j];
			nonbonded->addExclusion(idx,jdx);
// 			nbonded->addException(idx,jdx,chargeProd,0.0,0.0);
			}
		}
        	    // clear the mol id list for further assignment
            free(midx);

    }//first for loop ends
    printf("Total particles in system: %d\n", counter);
}


int extractOFPostoOMM(std::vector<Vec3>& posInNm,struct poly_solver_t* sol,
                      const boundBox& bb)
{
    posInNm.clear();
    int numMols = 0;
    int numParticles = 0;
    
    IDLList<polyMolecule>::iterator mol(sol->molecules->begin());
	for (mol = sol->molecules->begin(); mol != sol->molecules->end(); ++mol)
    {
        int molsize = mol().sitePositions().size();
        int m = 0;

        while (m<molsize) {
            Foam::vector rI = (mol().sitePositions()[m] - bb.min())*sol->refLength*NM;
            posInNm.push_back(Vec3(rI.x(), rI.y(), rI.z()));
            m++;
        }
        numParticles += molsize;
        numMols++;
    }
    
    return numParticles;
 
}

int setOFforce(struct poly_solver_t* solver, const std::vector<Vec3>& ommForces)
{
	IDLList<polyMolecule>::iterator mol(solver->molecules->begin());
	int numparticle = 0;

    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); ++mol){
        int molsize = mol().siteForces().size();
        int m = 0;
		while(m<molsize){
			mol().siteForces()[m] = Foam::vector                      
                        (
                            ommForces[numparticle][0],
                            ommForces[numparticle][1],
                            ommForces[numparticle][2]
                        )*NM2RUF/solver->refForce;
			numparticle++;
			m++;
		}
	}
	return numparticle;
}

//set OMM box
void setOMMBox(struct poly_solver_t* solver, const boundBox& bBoxOF,const double dt)
{
	solver->refLength = solver->redUnits->refLength();
	solver->refMass = solver->redUnits->refMass();
	solver->refForce = solver->redUnits->refForce();
	solver->refCharge = solver->redUnits->refCharge();
	solver->refTime = solver->redUnits->refTime();
	// Convert to femtoseconds [fs] for OpenMM: 
	solver->deltaT = dt*solver->refTime/FEM2SEC;
	
	//convert to reduced omm rcut size
	solver->rCutInNM = solver->molecules->pot().pairPotentials().rCutMax()*solver->refLength/NANO;
	// Convert individual bounding-box length-scales to nanometres [nm]
	double Lx = bBoxOF.span().x()*solver->refLength/NANO;
	double Ly = bBoxOF.span().y()*solver->refLength/NANO;
	double Lz = bBoxOF.span().z()*solver->refLength/NANO;
	//create boxsize for OMM 
	solver->bBoxOMMinNm = Vec3(Lx,Ly,Lz);
	
}


void addParticlesToNonBonded(CustomNonbondedForce* const nonbonded,
                                const struct poly_solver_t* solver)
{
    const List<word>& idlist = solver->molecules->pot().siteIdList();
    const std::string coefftype = solver->plid->coeffType();
    
    for(int i = 0; i < solver->plid->nIds(); ++i){
        const word& idAstr = idlist[i];
        nonbonded->addPerParticleParameter(idAstr);
    }
    /*
    if(coefftype == "lennardJones")
        nonbonded->addPerParticleParameter("q");
    */
    //set nonbondedmethod
    nonbonded->setNonbondedMethod(CustomNonbondedForce::CutoffPeriodic);
    nonbonded->setCutoffDistance(solver->rCutInNM);
}

void getOMMState(const Context* context,std::vector<Vec3>& statearray)
//        enum STATES st)
{
	statearray.clear();
	State state = context->getState(OpenMM::State::Forces|State::Energy,true);
	statearray = state.getForces();
        
}
