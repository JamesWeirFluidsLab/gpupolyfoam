#include "gpuUtilities.h"


void initialiseOMM(struct poly_solver_t* solver)
{
	// Load OpenMM platform-specific plugins:
    	
Platform::loadPluginsFromDirectory(Platform::getDefaultPluginsDirectory());
	int numPlatforms = Platform::getNumPlatforms();
	cout<<numPlatforms<<" OMM platforms found on this system"<<std::endl;
	for(int i=0;i<numPlatforms;i++)
   	{	
        Platform& tempPlatform = OpenMM::Platform::getPlatform(i);
		std::string tempPlatformName = tempPlatform.getName();
		cout << "Platform " << i << 
		" is " << tempPlatformName.c_str() << std::endl;
	}
	cout<<"==================================\n"<<std::endl;
	solver->system = new System();
	MOLECULE& tempmol = *solver->molecules;

        //get the scalling function required for this simulation
        Foam::word scallingfunction = getScallingFunction(tempmol);
        Info << "Scalling function " << scallingfunction << nl;
       
	//dynamic coeff string array
	std::vector<std::string> coeffStr;
/*
 * extract the coeff parameters generated by polyIdPairs class
 * from potentialDict
 */ 
        
	extractCoeffParameters(tempmol,*solver->plid,coeffStr);
        std::string coefftype = solver->plid->coeffType();
        Info << "CoeffType " << coefftype << nl;
        
        const label cs = solver->plid->coeffSize();
        const List<word>& coeffnames = solver->plid->coeffNames();
        
        std::stringstream tempstr;;
	/*
         * gather the N coeff parameters and their repective coeff string
         * generated by polyIdPairs.
         */
        for(int i=0;i<cs;++i){
            tempstr << coeffnames[i] << "= " << coeffStr[i] << ";";
        }
        
        std::string formulastr;
        
        if(coefftype == "lennardJones"){
            formulastr = 
            
"4*epsilon*((sigma/r)^12-(sigma/r)^6)+(138.9354561469*q)*(1/r-1/rCut+(r-rCut)/rCut^2); " 
            + tempstr.str() + " q=q1*q2";
        }
        else if(coefftype == "morse"){
            formulastr = "D*(exp(-2*alpha*(r-r0))-2*exp(-alpha*(r-r0)));"
                    + tempstr.str();
        }
        else{
            Info << "no coeff type found, quitting ..." << nl;
            exit(-1);
        }
        
        Info << "====Equation====" << nl;
        Info << formulastr << nl;

// Initialise customNonbonded force for OpenMM	
    CustomNonbondedForce* nonbonded;
    
    if(scallingfunction == "shiftedForce"){
        // ================================================
        // Coulomb potential with shifted force correction:
        // ================================================
        nonbonded = new CustomNonbondedForce(formulastr);
        nonbonded->addGlobalParameter("rCut",solver->rCutInNM);
    }
    else{
        Info << "Error: (Solver) Cannot find electrostatic potential" <<
                "specification in potentialDict" << nl;
        exit(-1);
    }
    
    //add per particles to nonbonded force
    addParticlesToNonBonded(nonbonded,solver);
//set OMM box size
    solver->system->setDefaultPeriodicBoxVectors(
        Vec3(solver->bBoxOMMinNm[0],0,0),
        Vec3(0,solver->bBoxOMMinNm[0],0),
        Vec3(0,0,solver->bBoxOMMinNm[0])
        );

/**
 * extract OF information to initialise the
 * system inside openmm, this information includes
 * masses, exclusion list, custom parameters, etc
 */
    extractOFParticles(solver,nonbonded);
    
    Info << "CUSTOMNONBONDEDFORCE INFO"<<nl;
    Info << "Num particles "<< nonbonded->getNumParticles() << nl;
    Info << "Num exclusion "<< nonbonded->getNumExclusions() << nl;
    Info << "Num perparticle params "<< nonbonded->getNumPerParticleParameters() 
<< nl;
    Info << "Num global params "<< nonbonded->getNumGlobalParameters() << nl;
    Info << "Nonbonded method "<< nonbonded->getNonbondedMethod() << nl;
    Info << "Cutoff distance "<< nonbonded->getCutoffDistance() << nl;
    Info << "==============================="<<nl;    

    
    solver->system->addForce(nonbonded);
    
    Platform& platform = Platform::getPlatformByName("OpenCL");
    solver->integrator =  new VelocityVerletIntegrator(solver->deltaT*OpenMM::PsPerFs);
    solver->context = new Context(*solver->system,*solver->integrator,platform);
    
    Info << "Initialised sytem on OMM with " <<
        solver->system->getNumParticles() <<
        " particles " << nl;
    Info << "Using OMM "<<
        solver->context->getPlatform().getName().c_str() <<
    	" platform " << nl;
    
}


void extractCoeffParameters(const MOLECULE& mol,
			const polyIdPairs& p,
			std::vector<std::string>& coeffStr)
{

	const List<word>& idList = mol.pot().siteIdList();
	const List<word>& coefflist = p.coeffNames();
	label coeffsize = coefflist.size();
	std::vector<std::string> coeffstr(coeffsize);

	int counter = 0;
	for(label c = 0; c < coeffsize; ++c)
	{
		counter = 0;
		forAll(p.coeffVals()[c],i){
			forAll(p.coeffVals()[c][i],j){
				const word& idAStr = idList[i];
				const word& idBStr = idList[j];
//TODO: delete later if all is well				
				scalar coeffAB;
                                
				if(coefflist[c] == "sigma")
                                    coeffAB = p.coeffVals()[c][i][j]/1e-9;
				else if(coefflist[c] == "epsilon")
                                    coeffAB = 
p.coeffVals()[c][i][j]*6.02214129e23/1e3f;
                                else if(coefflist[c] == "D")
                                    coeffAB = p.coeffVals()[c][i][j] * 
6.02214129e20;
                                else if(coefflist[c] == "alpha")
                                    coeffAB = p.coeffVals()[c][i][j] * 1.0f / 
1e9;
                                else if(coefflist[c] == "r0")
                                    coeffAB = p.coeffVals()[c][i][j] * 1e9;
                                
				std::string ABstr;
				std::stringstream outAB;		
				outAB << coeffAB;
				ABstr = outAB.str();
				std::string tempstr = 
ABstr+"*("+idAStr+"1*"+idBStr+"2)";

				if(counter == 0)
					coeffstr[c] = coeffstr[c]+""+tempstr;
				else
					coeffstr[c] = coeffstr[c]+" + "+tempstr;	
		
				counter++;
			}
		}
	}

	for(counter = 0; counter < coeffsize; ++counter)
		coeffStr.push_back(coeffstr[counter]);
}

void extractOFParticles(struct poly_solver_t* solver,
                        CustomNonbondedForce* const nonbonded)
{
    const std::string coefftype = solver->plid->coeffType();
    int temp = 0;
    
    if(coefftype == "lennardJones")
        temp = solver->plid->nIds() + 1;
    else
        temp = solver->plid->nIds();
    
    const int species = temp;
    int numMolecules = 0;
    int numParticles = 0;
    
    int* midx=NULL;
	 
    MOLECULE& mol = *solver->molecules;
    IDLList<polyMolecule>::iterator m(mol.begin());
    for (m = mol.begin(); m != mol.end(); ++m)
    {
            const polyMolecule::constantProperties& constprop = 
                    mol.constProps(m().id());
            int molsize = constprop.sites().size();
            numMolecules++;

            //allocate memory for array holding molecule index based on molecule size
            midx = (int*) malloc(sizeof(int)*molsize);

            //now traverse throught the N sites of each molecule size obtained
            //from previous retrive
            int itr = 0;
            while(itr<molsize)
            {
                double tempmolmass = constprop.sites()[itr].siteMass()
                        *solver->refMass/DALTON;
                double tempmolcharge = constprop.sites()[itr].siteCharge()
                        *solver->refCharge/CHARGE;
                midx[itr]  = solver->system->addParticle(tempmolmass);
                int sid = constprop.sites()[itr].siteId();
         
                std::vector<double> params(species);
                for(int k=0;k<species;k++)
                    params[k]=0;
                params[sid] = 1;
                if(coefftype == "lennardJones")
                        params[species-1] = tempmolcharge;
                
                nonbonded->addParticle(params);
                itr++;
                numParticles++;
            }
            //add exclusion for each molecule obtained
            if(molsize>1)
			for(int i=0;i<molsize-1;i++)
				for(int j=i+1;j<molsize;j++)
					
            nonbonded->addExclusion(midx[i],midx[j]);
            // clear the mol id list for further assignment
            free(midx);

    }//first for loop ends
    
    solver->isMolecular = (bool) numMolecules != numParticles;
    //solver->system->setIsMolecular(solver->isMolecular);
    
    if(solver->isMolecular){
        /**
         * if the simulation is molecular then assign the required
         * information to the openmm system to enable molecular integration
         * to occur seamlessly 
         * 
         * *assign the unique number of molecules in the simulation
         * by obtaining the number from openfoam
         * 
         * *assign the values of moment of inertia
         */
        label uniquemolnumber = solver->pot->idList().size();
        solver->system->setNumberofIds(uniquemolnumber);
        
        int n = 0;
        double lengthnm = solver->refLength * NM;
        
        while(n<uniquemolnumber){
            const polyMolecule::constantProperties& constprop = 
                    mol.constProps(n);
            const diagTensor& m = constprop.momentOfInertia();
            solver->system->addMomentofInertia(
                OpenMM::Vec3(m.xx()*lengthnm,m.yy()*lengthnm,m.zz()*lengthnm));
            n++;
        }
    }
}


int extractOFPostoOMM(std::vector<Vec3>& posInNm,struct poly_solver_t* sol,
                      const boundBox& bb)
{
    posInNm.clear();
    int numMols = 0;
    int numParticles = 0;
    
    IDLList<polyMolecule>::iterator mol(sol->molecules->begin());
	for (mol = sol->molecules->begin(); mol != sol->molecules->end(); ++mol)
    {
        int molsize = mol().sitePositions().size();
        int m = 0;

        while (m<molsize) {
            Foam::vector rI = (mol().sitePositions()[m] - 
bb.min())*sol->refLength*NM;
            posInNm.push_back(Vec3(rI.x(), rI.y(), rI.z()));
            m++;
            numParticles += 1;
        }
        numMols++;
    }
    
    return numParticles;
 
}

int extractOFVeltoOMM(std::vector<Vec3>& velInNm, struct poly_solver_t* sol,int particles)
{
	int numMols = 0;
	velInNm.clear();
	const double nmconversion = sol->refVelocity*1e-12/NANO;
    	
	IDLList<polyMolecule>::iterator mol(sol->molecules->begin());
	
	for (mol = sol->molecules->begin(); mol != sol->molecules->end(); 
++mol){
		numMols++;
		Foam::vector vi = mol().v()*nmconversion;
		velInNm.push_back(Vec3(vi.x(),vi.y(),vi.z()));
	}
	
	//make remaining particles to zero
	while(numMols<particles){
	    velInNm.push_back(Vec3(0.0,0.0,0.0));
	    numMols++;
	}
	return numMols;
}
int setOFforce(struct poly_solver_t* solver, const std::vector<Vec3>& ommForces)
{
	IDLList<polyMolecule>::iterator mol(solver->molecules->begin());
	int numparticle = 0;

    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); 
++mol){
        int molsize = mol().siteForces().size();
        int m = 0;
		while(m<molsize){
			mol().siteForces()[m] = Foam::vector                     
 
                        (
                            ommForces[numparticle][0],
                            ommForces[numparticle][1],
                            ommForces[numparticle][2]
                        )*NM2RUF/solver->refForce;
			numparticle++;
			m++;
		}
	}
	return numparticle;
}

//set OMM box
void setOMMBox(struct poly_solver_t* solver, const boundBox& bBoxOF,const double 
dt)
{
	solver->refLength = solver->redUnits->refLength();
	solver->refMass = solver->redUnits->refMass();
	solver->refForce = solver->redUnits->refForce();
	solver->refCharge = solver->redUnits->refCharge();
	solver->refTime = solver->redUnits->refTime();
	solver->refVelocity = solver->redUnits->refVelocity();
	// Convert to femtoseconds [fs] for OpenMM: 
	solver->deltaT = dt*solver->refTime/FEM2SEC;
	
	//convert to reduced omm rcut size
	solver->rCutInNM = 
solver->molecules->pot().pairPotentials().rCutMax()*solver->refLength/NANO;
	// Convert individual bounding-box length-scales to nanometres [nm]
	double Lx = bBoxOF.span().x()*solver->refLength/NANO;
	double Ly = bBoxOF.span().y()*solver->refLength/NANO;
	double Lz = bBoxOF.span().z()*solver->refLength/NANO;
	//create boxsize for OMM 
	solver->bBoxOMMinNm = Vec3(Lx,Ly,Lz);
	
}


void addParticlesToNonBonded(CustomNonbondedForce* const nonbonded,
                                const struct poly_solver_t* solver)
{
    const List<word>& idlist = solver->molecules->pot().siteIdList();
    const std::string coefftype = solver->plid->coeffType();
    
    for(int i = 0; i < solver->plid->nIds(); ++i){
        const word& idAstr = idlist[i];
        nonbonded->addPerParticleParameter(idAstr);
    }
    if(coefftype == "lennardJones")
        nonbonded->addPerParticleParameter("q");
    
    //set nonbondedmethod
    nonbonded->setNonbondedMethod(CustomNonbondedForce::CutoffPeriodic);
    nonbonded->setCutoffDistance(solver->rCutInNM);
}

void getOMMState(const Context* context,std::vector<Vec3>& statearray)
//        enum STATES st)
{
	statearray.clear();
	State state = 
context->getState(OpenMM::State::Forces|State::Energy,true);
	statearray = state.getForces();
        
}

int extractOFQ(const struct poly_solver_t* solver, std::vector<OpenMM::Tensor>& moleculeQ)
{
    int numMols = 0;
    moleculeQ.clear();
    
    IDLList<polyMolecule>::iterator mol(solver->molecules->begin());
    
    for (mol = solver->molecules->begin(); mol != solver->molecules->end(); ++mol)
    {
	numMols++;
	Foam::tensor& temp = mol().Q();
	moleculeQ.push_back(
	      OpenMM::Tensor(temp.xx(),temp.xy(),temp.xz(),
	      temp.yx(),temp.yy(),temp.yz(),
	      temp.zx(),temp.zy(),temp.zz()));
    }
    
    return numMols;
}

int extractOFSiteRefPositions(const struct poly_solver_t* solver, std::vector<OpenMM::Vec3>& siteRefPositions)
{
    const double converter = solver->refLength*NM;
    
}